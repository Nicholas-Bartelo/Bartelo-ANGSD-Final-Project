---
title: "Performing Analysis Using Read Count Table"
author: "Nick Bartelo"
date: "3/18/2021"
output: html_document
---

## Importing Read Count Table

We first copy the final_project_featCounts_mouse_genes.txt and final_project_featCounts_mouse_genes.txt.summary (found in SCU at /home/nib4003/ANGSD_2021_hw/final_project/counting_reads_for_all_samples) files from the SCU to the R project folder we are using for final project files. This allows us to read in the files easily and keep the data together. 

Below we import the libraries we will need for our analyses, and also show the readcounts table.

```{r}
library(tidyverse)
library(ggplot2)
library(magrittr)
library(DESeq2)
library(hexbin)
library(org.Sc.sgd.db)
library(EnhancedVolcano)
library(patchwork)
readcounts <- paste0("final_project_featCounts_mouse_genes_stranded.txt") %>% read.table(., header=TRUE)
str(readcounts)
```

The sample names are a bit annoying since they contain the entire SAM file name. Let's turn these into more useful identifiers.

```{r}
# Keep a back-up copy of the original names
orig_names <- names(readcounts) 
# Change names 
names(readcounts) <-c(names(readcounts)[1:6],paste("DIABETES",c(1:3), sep = "_"),paste("HETEROZYGOUS",c(1:3), sep = "_"),paste("WT",c(1:3),sep="_") )
#names(readcounts) <- gsub(".*(DIABETES|HETEROZYGOUS|WT)(_[0-9]+).*", "\\1\\2", orig_names)
str(readcounts)
```

## CountData 

In principle, readcounts is pretty much already in the format that we will need (columns = Samples, rows = genes), but we are missing row.names and the first couple of columns contain meta data information that need to be separated from the counts (e.g. gene Ids, gene lengths, etc.)

```{r}
row.names(readcounts) <- make.names(readcounts$Geneid)
## exclude the columns without read counts (columns 1 to 6 contain additional
## info such as genomic coordinates)
readcounts <- readcounts[ ,-c(1:6)]

head(readcounts)
```

```{r}
 #let's use the info from our readcounts objects
sample_info <- DataFrame(condition =gsub("_[0-9]+", "",names(readcounts)),row.names =names(readcounts) )

sample_info # rows contain gene information for each sample
```


## Generate the DESeqDataSet

```{r}
DESeq.ds <- DESeqDataSetFromMatrix(countData = as.matrix(readcounts), colData = sample_info, design = ~ condition)
DESeq.ds
head(counts(DESeq.ds))
```

How many reads were sequenced for each sample ( = library sizes)?
f(x) = condition*x<=>readcouns ~ condition

```{r}
colSums(counts(DESeq.ds)) %>% barplot
```

Remove genes with no reads:

```{r}
dim(DESeq.ds)

keep_genes <- rowSums(counts(DESeq.ds)) > 0
DESeq.ds <- DESeq.ds[ keep_genes, ]
dim(DESeq.ds)
```


## Assumptions of DESeq’s size factor method:

* There is the assumption that most genes are not changing across conditions!
* Size factors should be around 1.
* Normalized counts are calculated so: $\frac{counts_{geneX,sampleA}}{sizefactor_{sampleA}}$ 

## Calculating and applying the size factor

```{r}
DESeq.ds <- estimateSizeFactors(DESeq.ds)
# calculate SFs, add them to object
plot(sizeFactors(DESeq.ds),colSums(counts(DESeq.ds)), ylab = "library sizes", xlab = "size factors", cex = .6 )
```


## Reducing the dependence of the variance on the mean

DESeq offers two ways to shrink the log-transformed counts for genes with very low counts: rlog and varianceStabilizingTransformation(vst). 

We’ll use rlog here as it is an optimized method for RNA-seq read counts: it transforms the read counts to the log2 scale while simultaneously minimizing the difference between samples for rows with small counts and taking differences between library sizes of the samples into account. More specifically, the expression values are modeled in such a manner that their dispersion is not based on the actual variability an individual gene may show across its replicates, instead, its variability is based on the general dispersion-mean trend over the entire dataset.This is possible because DESeq2 assumes that ‘genes of similar average expression strength have similar dispersion"; this is important as it allows us to base our estimation of the noise on a much larger data set than the original number of replicates. For example, in our dataset, we only have 10 values per gene. That is not a lot of values to robustly estimate the noise; however, following DESeq2’s assumption, we can increase our number of data points significantly by assuming that all genes that share similar average expression values across all samples should also display similar noise levels. This assumption works very well on a global scale, but it also means that you cannot take the rlog values at face value when looking at single genes, because their values are a strong reflection of all of the values for genes in the same expression strength bin.The vst methods tends to depend a bit more on the differences in sequencing depths, but generally, both methods should return similar results.

```{r}
# this actually generates a different type of object!
DESeq.rlog <-rlog(DESeq.ds, blind = TRUE)
## set blind = FALSE if the conditions are expected to introduce
## strong differences in a large proportion of the genes
```

Let’s visually check the results of the rlog transformation:

```{r}
par(mfrow=c(1,2))


## the rlog-transformed counts are stored in the accessor "assay"
plot(assay(DESeq.rlog)[,1],assay(DESeq.rlog)[,2],cex=.1, main = "rlog transformed",xlab =colnames(assay(DESeq.rlog[,1])),ylab =colnames(assay(DESeq.rlog[,2])) )
```

```{r}
rlog.norm.counts <-assay(DESeq.rlog)
```

```{r}
## rlog-transformed read counts
msd_plot <- vsn::meanSdPlot( rlog.norm.counts, ranks=FALSE, plot = FALSE)
msd_plot$gg+ ggtitle("rlog transformation") + coord_cartesian(ylim =c(0,3))
```
It’s not perfect, but it looks much better than before.
Now, we have expression values that have been adjusted for:
* differences in sequencing depth;
* differences in RNA composition;
* heteroskedasticity;
* large dynamic range.

These values can now be used for exploratory analyses– for DE analyses, we will eventually supply the raw counts, though (because the DE tests will require their own modeling of the gene counts).


```{r}
DESeq.ds
DESeq.ds$condition
DESeq.ds$condition <- relevel(DESeq.ds$condition, ref = 'WT')
```

Now, let's perform DE analysis!

```{r}
DESeq.ds <- DESeq(DESeq.ds)
```

Below we show that now we have row data, whereas DESeq.ds did not have this before.

```{r}
DESeq.ds
```

To look at the DE in a new way:

```{r}
DGE.results <- results(DESeq.ds)
dim(DGE.results)
# Find how many significant genes. There are ~43% of genes that show significant DE 
table(DGE.results$padj < 0.05)
```

Use heatmap (DON'T USE THIS HEATMAP (PHEATMAP) USE COMPLEX HEATMAP IN R) for getting an impression of the robustness of the expression changes to gauge the noise levels and see how many are upregulated and downregulated. The y-axis is all the significant genes.:

```{r}
DGEgenes <- subset(DGE.results, padj < 0.05) %>% rownames

# Get all rlog values for significant genes ([DGEgenes, ] gives all rows of significant genes and all their columns)
rlog.dge <- DESeq.rlog[DGEgenes, ] %>% assay

library(pheatmap)
pheatmap(rlog.dge, scale='none')
```

Make the heatmap more readable. We see that the noise levels for WT are a bit higher than that of the SNF2. 

```{r}
pheatmap(rlog.dge, scale='row', show_rownames = FALSE, main = 'DGE genes with row-z-score') # With z-score
```

## LogFC values

Despite the fact that many visualizations will use the normalized read counts per sample, e.g. by simply focusing on that subset of genes that passed the adjusted p-value threshold, it is often useful to interrogate the fold change values that were estimated (i.e., the magnitude) of change as well. Many researchers believe that subtle fold changes are more difficult to interpret than dramatic differences in expression; therefore you may find yourself wanting to rank the genes by the logFC values in addition to their statistical significance as implied by their adjusted p-values.

### MA-plots and volcano plots

The MA-plot provides a global view of the differential genes, with the log2 fold change on the y-axis over the mean of normalized counts. Genes that pass the significance threshold (adjusted p.value <0.05) are colored in red.

```{r}
plotMA(DGE.results, alpha = 0.05, main = "Test: p.adj.value < 0.05", ylim =c(-4,4))
```

```{r}
library(EnhancedVolcano)
vp1 <-EnhancedVolcano(DGE.results,lab =rownames(DGE.results),x ='log2FoldChange',y ='padj', pCutoff = 0.05,title = "Diabetes / Heterozygous / WT")
print(vp1)
```

## Shrinking logFC

Adjusts for types of noise we might see. Tend to be more reliable and more robust. 

```{r}
# BiocManager::install('apeglm')
DGE.results.shrink <- lfcShrink(DESeq.ds, coef = 2, type = 'apeglm')
```

Let’s see what the effect of the shrinkage is on the MA plot:

```{r}
par(mfrow =c(1,2))
plotMA(DGE.results, alpha = 0.05,main = "no shrinkage", ylim =c(-4,4))
DGE.results.shrnk <-lfcShrink(DESeq.ds, coef = 2, type = "apeglm")
plotMA(DGE.results.shrnk,alpha = 0.05,main = "with logFC shrinkage", ylim =c(-4,4))
```


```{r}
vp2 <-EnhancedVolcano(DGE.results.shrnk,lab =rownames(DGE.results.shrnk),x ='log2FoldChange',y ='padj', pCutoff = 0.05,title = "with logFC shrinkage")
library(patchwork)
vp1+vp2
```